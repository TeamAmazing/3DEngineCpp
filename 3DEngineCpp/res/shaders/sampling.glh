
vec2 CalcParallaxTexCoords(sampler2D dispMap, mat3 tbnMatrix, vec3 directionToEye, vec2 texCoords, float scale, float bias)
{
	return texCoords.xy + (directionToEye * tbnMatrix).xy * (texture2D(dispMap, texCoords.xy).r * scale + bias);
}

//compare is distance to closest point
float SampleShadowMap(sampler2D shadowMap, vec2 coords, float compare)
{
	//zero if farther away from light return 0.0, closer return 1.0 (Texture2d.r is luminance)
	return step(compare, texture2D(shadowMap, coords.xy).r);
}

//compare is distance to closest point
float SampleShadowMapLinear(sampler2D shadowMap, vec2 coords, float compare, vec2 texelSize)
{
	vec2 pixelPos = coords/texelSize + vec2(0.5);
	vec2 fracPart = fract(pixelPos);
	vec2 startTexel = (pixelPos - fracPart) * texelSize;

	float blTexel = SampleShadowMap(shadowMap, startTexel, compare);
	float brTexel = SampleShadowMap(shadowMap, startTexel + vec2(texelSize.x, 0.0f), compare);
	float tlTexel = SampleShadowMap(shadowMap, startTexel + vec2(0.0f, texelSize.y), compare);
	float trTexel = SampleShadowMap(shadowMap, startTexel + texelSize.x, compare);

	float mixA = mix(blTexel, tlTexel, fracPart.y);
	float mixB = mix(brTexel, trTexel, fracPart.y);
	return mix(mixA, mixB, fracPart.x);
}

//compare is distance to closest point
//THIS IS PCF!
float SampleShadowMapPCF(sampler2D shadowMap, vec2 coords, float compare, vec2 texelSize)
{
	//NUM_SAMPLES*NUM_SAMPLES*ShadowMapLinear(its 4) calculations, so keep NUM_SAMPLES low.
	const float NUM_SAMPLES = 5.0f;
	const float SAMPLES_START = (NUM_SAMPLES-1.0f)/2.0f;
	const float NUM_SAMPLES_SQUARED = NUM_SAMPLES*NUM_SAMPLES;

	float result = 0.0f;
	for(float x = -SAMPLES_START; x <= SAMPLES_START ; x += 1.0f)
	{
		for(float y = -SAMPLES_START; y <= SAMPLES_START ; y += 1.0f)
		{
			vec2 coordsOffset = vec2(x,y) * texelSize;
			result += SampleShadowMapLinear(shadowMap, coords + coordsOffset, compare, texelSize);
		}
	}
	//divide by 9 cause 9 samples in the forloops.
	return (result/NUM_SAMPLES_SQUARED);
}

float linstep(float low, float high, float v) 
{
	// Linear interpolation
	return clamp((v-low)/(high-low), 0.0, 1.0);
}

//compare is distance to closest point
float SampleVarianceShadowMap(sampler2D shadowMap, vec2 coords, float compare, float varianceMin, float lightBleedReductionAmount)
{
	vec2 moments = texture2D(shadowMap, coords.xy).xy;

	float p = step(compare, moments.x);
	//its zero!
	float variance = max(moments.y - moments.x * moments.x, varianceMin);

	float d = compare - moments.x;
	float pMax = linstep( lightBleedReductionAmount, 1.0, variance / (variance + d*d));
	//Clamp hack to avoid light bleeding
	//float pMax = clamp(variance / (variance + d*d), 0.2, 1.0) - 0.2;

	return min(max(p, pMax), 1.0);

}